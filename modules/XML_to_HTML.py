import re
import os
from datetime import timedelta, datetime
import xml.etree.ElementTree as ET
from jinja2 import Environment, FileSystemLoader
from matplotlib import pyplot as plt

from .time_convert import format_duration

from .sort import DictionaryList
from .configuration import reports_dir, logs_dir


def parse_tests_from_directory(directory):
    """
    Parses all XML files in a given directory and returns a list of dictionaries representing each test case.

    Args:
        directory (str): The path to the directory containing XML files.

    Returns:
        list: A list of dictionaries, each representing a test case.

    """
    tests = []
    for file in os.listdir(directory):
        if file.endswith(".xml"):
            tests.extend(parse_tests_from_xml(os.path.join(directory, file)))
    return tests


def parse_tests_from_xml(xml_file):
    """
    Parses an XML file with test results and returns a list of dictionaries representing each test case.

    Args:
        xml_file (str): The path to the XML file to be processed.

    Returns:
        list: A list of dictionaries, each representing a test case. Each dictionary contains the following keys:
            - "Results" (str): The result of the test case ("Passed", "Failed", etc.).
            - "scenario" (str): The name of the scenario or test case.
            - "duration" (str): The duration of the test case in HH:MM:SS format.
            - "log" (list): A list of log entries related to the test case.

    Raises:
        XMLParseError: If there is an error parsing the XML file.

    Notes:
        This function is intended for internal use within the module and is not designed for external consumption.
        It expects the XML file to follow the JUnit XML format commonly generated by many test frameworks.
    """
    tree = ET.parse(xml_file)
    root = tree.getroot()

    tests = []

    for testcase in root.findall('testcase'):
        # Get the status
        status = testcase.get('status')
        if status is None:
            results = "No Status"
        else:
            results = status

        # Get the scenario name
        scenario = testcase.get('name')

        # Get the duration and convert it to the desired format
        time_seconds = float(testcase.get('time'))

        # Get the log content
        system_out = testcase.find('system-out').text if testcase.find('system-out') is not None else ""
        log = system_out

        # Split the string based on newlines and convert it into a list
        log_to_list_of_logs = log.split('\n')

        # Remove empty items from the list
        log_to_list_of_logs = [line for line in log_to_list_of_logs if line.strip()]

        # Initialize the new list for objects
        objects_list = []

        # Regex patterns for finding time and result
        time_pattern = re.compile(r'\d+\.\d+s')
        result_pattern = re.compile(r'passed|skipped|failed|no status')

        is_end_of_log = False
        include_scenario_word = False
        is_main_content = False
        combined_log = ""

        # Process the list to build the objects
        for log_item in log_to_list_of_logs:
            if is_end_of_log:
                combined_log += log_item + "\n"
                continue

            # Search for time and result in the log item
            time_match = time_pattern.search(log_item)
            result_match = result_pattern.search(log_item)

            # Initialize extractions
            time = time_match.group(0) if time_match else None
            result = result_match.group(0) if result_match else None

            # Modify log item by removing time and result
            step = log_item
            if time:
                step = step.replace(time, '').strip()
            if result:
                step = step.replace(result, '').strip()
            step = step.replace(' in', '').strip()  # Remove the word 'in'

            if "@scenario.end" in step:
                is_end_of_log = True
                is_main_content = False
                include_scenario_word = False

            if step == "":
                continue

            if include_scenario_word:
                is_main_content = True

            if "Scenario:" in step:
                include_scenario_word = True

            # Create the object and add it to the list
            log_object = {
                'Step': step.replace(" ...", ""),
                'Time': time,
                'Result': result,
                'End': is_end_of_log,
                'is_main_content': is_main_content,
                'include_scenario_word': include_scenario_word
            }
            objects_list.append(log_object)

        # Add the combined log if there is one
        if combined_log.strip():
            objects_list.append({
                'Step': combined_log.strip(),
                'Time': None,
                'Result': None,
                'End': True,
                'is_main_content': False,
                'include_scenario_word': False
            })

        tests.append({
            "Results": results,
            "scenario": scenario,
            "duration": time_seconds,
            "log": objects_list
        })

    return tests


def count(data):
    """
    Counts the number of test cases with different outcomes (Passed, Failed, Skipped, No Status).

    Args:
        data (list): A list of dictionaries representing test cases.

    Returns:
        dict: A dictionary with keys 'count_passed', 'count_failed', 'count_skipped', and 'count_nostatus',
              representing the number of test cases for each outcome category.

    """
    count_passed = 0
    count_failed = 0
    count_skipped = 0
    count_nostatus = 0
    count_errors = 0
    count_expected_failures = 0
    count_unexpected_passes = 0
    count_reruns = 0
    total_duration = timedelta(seconds=0)

    for item in data:
        if item["Results"] == "passed":
            count_passed += 1
        elif item["Results"] == "failed":
            count_failed += 1
        elif item["Results"] == "skipped":
            count_skipped += 1
        elif item["Results"] == "no status":
            count_nostatus += 1
        elif item["Results"] == "error":
            count_errors +=1
        elif item["Results"] == "expected failure":
            count_expected_failures +=1
        elif item["Results"] == "unexpexted passed":
            count_unexpected_passes +=1
        elif item["Results"] == "rerun":
            count_reruns +=1


        if "duration" in item:
            duration_str = item["duration"]
            try:
                duration_seconds = float(duration_str)
                total_duration += timedelta(seconds=duration_seconds)
            except ValueError:
                pass  # Handle invalid duration string (optional)

    # Convert total_duration back to text form (optional, depending on requirements)
    total_duration_text = str(total_duration)

    return {
        "count_passed": count_passed,
        "count_failed": count_failed,
        "count_skipped": count_skipped,
        "count_nostatus": count_nostatus,
        "total_duration": total_duration_text,
        "count_errors": count_errors,
        "count_expected_failures": count_expected_failures,
        "count_unexpected_passes": count_unexpected_passes,
        "count_reruns": count_reruns
    }


def build_html_report(tests, reports_dir, file_or_dir_name):
    """
    Builds an HTML report using Jinja2 templates.

    Args:
        tests (list): A list of dictionaries, each representing a test case.
        reports_dir (str): The directory where the HTML report should be saved.
        file_or_dir_name (str): The filename for the HTML report (without the .html extension).

    """
    # Load the Jinja2 template environment
    file_loader = FileSystemLoader('template')  # Assuming templates are in a 'template' directory
    env = Environment(loader=file_loader)

    # Load the template file
    template = env.get_template('report_template.html')  # Assuming the template file is 'report_template.html'

    # Get the current date and time in the desired format
    generated_at = datetime.now().strftime("%d-%b-%Y at %H:%M:%S")

    counter = count(tests)
    # plt.figure()
    # Render the template with data
    rendered_html = template.render(
        data=tests,
        count_passed=counter["count_passed"],
        count_failed=counter["count_failed"],
        count_skipped=counter["count_skipped"],
        count_nostatus=counter["count_nostatus"],
        count_reruns=counter["count_reruns"],
        count_expected_failures=counter["count_expected_failures"],
        count_unexpected_passes=counter["count_unexpected_passes"],
        count_errors=counter["count_errors"],
        rapportname=file_or_dir_name,
        generated_at=generated_at,
        amount_of_tests=len(tests),
        total_duration=format_duration(counter["total_duration"])
    )

    # Ensure the reports directory exists
    os.makedirs(reports_dir, exist_ok=True)

    # Write the rendered HTML to a file
    with open(f'{reports_dir}/{file_or_dir_name}.html', 'w', encoding='utf-8') as f:
        f.write(rendered_html)


def run_xml_to_html():
    """
    Reads configuration from settings.cfg to determine the location of XML files,
    processes each XML file in the specified directory to generate corresponding HTML reports.

    """
    sort_by = ["Failed", "Errors", "Expected failures", "Unexpected passes", "Skipped", "Reruns", "Passed"]

    if not os.path.exists(reports_dir):
        os.makedirs(reports_dir)

    # Process XML files directly in the main logs_dir
    for file in os.listdir(logs_dir):
        if file.endswith(".xml"):
            tests = parse_tests_from_xml(os.path.join(logs_dir, file))
            dl = DictionaryList(tests, sort_by)
            dl.sort_by_key("Results")
            sorted_tests = dl.to_list()
            build_html_report(sorted_tests, reports_dir, file)

    # Process XML files within each subdirectory of logs_dir
    for root, dirs, files in os.walk(logs_dir):
        for dir_name in dirs:
            dir_path = os.path.join(root, dir_name)
            tests = parse_tests_from_directory(dir_path)

            # Sort the tests by "Results" key
            dl = DictionaryList(tests, sort_by)
            dl.sort_by_key("Results")
            sorted_list = dl.to_list()

            # Build HTML report for the sorted list
            build_html_report(sorted_list, reports_dir, dir_name)
